#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     left1,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     left2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     right1,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     right2,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    hook,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int gyroOffset = SensorValue(gyro);

// read the gyroscope
float readGyro()
{
	return -((float) (SensorValue(gyro) - gyroOffset));
}

task main()
{
	//waitForStart();

	// PID parameters
	float k = 0.5,
				kI = 0,
				kD = 0;

	// other parameteres
	float orientation = 0,
      leftSpeed = 20,
      rightSpeed = 20,
      target = 0,
      lastError = 0,
      timeDiff, reading, avgSpeed,
      error, sumError, dError, spread;
  int lastTime = 0,
  		index = 0,
  		currentTime;

  ClearTimer(T1);

  while (true) {
  	nxtDisplayBigTextLine(1, "%d", orientation);
    // calculate the time difference
    currentTime = time1[T1];
    timeDiff = (currentTime - lastTime) / 1000.0;
    lastTime = currentTime;

    // read the gyro
    reading = readGyro();
    orientation += reading * timeDiff;

    // log the orientation
    writeDebugStreamLine("%f", orientation);

    // update the PID controls
    error = target - orientation;
    sumError += error * timeDiff;
    dError = (error - lastError) / timeDiff;

    // calculate the spread
    spread = k * (error + (kI == 0 ? 0 : 1 / kI) * sumError + (kD == 0 ? 0 : 1 / kD) * dError);
    avgSpeed = (leftSpeed + rightSpeed) / 2;
    leftSpeed = avgSpeed * (1.0 - spread / 2.0);
    rightSpeed = avgSpeed * (1.0 + spread / 2.0);

    // actually set the speed of the motorSpeeds
    motor[left1] = leftSpeed;
    motor[left2] = leftSpeed;
    motor[right1] = -rightSpeed;
    motor[right2] = rightSpeed;

    // stop if more than 10 seconds have passed
    //if (currentTime / 1000 > 10) {
    //  break;
    //}

    // wait a little for the next loop iteration
    wait1Msec(50);
  }

  // stop the motors
  motor[left1] = 0;
  motor[left2] = 0;
  motor[right1] = 0;
  motor[right2] = 0;
}
